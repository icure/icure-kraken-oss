<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../../../bower_components/polymer/polymer.html">

<link rel="import" href="../../../bower_components/iron-meta/iron-meta.html">
<link rel="import" href="../../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../../bower_components/iron-iconset-svg/iron-iconset-svg.html">
<link rel="import" href="../../../bower_components/iron-iconset/iron-iconset.html">

<link rel="import" href="../../../bower_components/iron-icons/iron-icons.html">
<link rel="import" href="../../../bower_components/iron-icons/maps-icons.html">
<link rel="import" href="../../../bower_components/iron-icons/social-icons.html">
<link rel="import" href="../../../bower_components/iron-icons/device-icons.html">
<link rel="import" href="../../../bower_components/iron-icons/av-icons.html">
<link rel="import" href="../../../bower_components/iron-icons/hardware-icons.html">
<link rel="import" href="../../../bower_components/iron-icons/editor-icons.html">
<link rel="import" href="../../../bower_components/iron-icons/communication-icons.html">
<link rel="import" href="../../../bower_components/iron-icons/image-icons.html">
<link rel="import" href="../../../bower_components/iron-icons/maps-icons.html">

<link rel="import" href="../../../bower_components/iron-icon/iron-icon.html">

<link rel="import" href="../../../bower_components/vaadin-grid/vaadin-grid.html">
<link rel="import" href="../../../bower_components/vaadin-grid/vaadin-grid-column.html">

<link rel="import" href="../../../bower_components/paper-card/paper-card.html">
<link rel="import" href="../../../bower_components/paper-listbox/paper-listbox.html">
<link rel="import" href="../../../bower_components/paper-item/paper-item.html">
<link rel="import" href="../../../bower_components/paper-fab/paper-fab.html">
<link rel="import" href="../../../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../../../bower_components/paper-styles/shadow.html">

<link rel="import" href="../../../bower_components/paper-tooltip/paper-tooltip.html">
<link rel="import" href="../../../bower_components/paper-toast/paper-toast.html">

<link rel="import" href="../../../bower_components/paper-input/paper-input.html">
<link rel="import" href="../../../bower_components/paper-input/paper-input-container.html">
<link rel="import" href="../../../bower_components/paper-input/paper-textarea.html">

<link rel="import" href="../filter-panel/filter-panel.html">

<link rel="import" href="../collapse-button/collapse-button.html">

<link rel="import" href="../icons/icure-icons.html">
<link rel="import" href="../../icd-styles.html">

<link rel="import" href="../dynamic-form/entity-selector.html">
<link rel="import" href="../dynamic-form/health-problem-selector.html">

<dom-module id="ht-msg-menu">
	<template>
		<style include="iron-flex iron-flex-alignment"></style>
		<!--suppress CssUnusedSymbol -->
		<style include="shared-styles">
			:host {
				display: block;
			}

			:host *:focus{
				outline:0!important;
			}

			.col-left{
				position:fixed;
				box-sizing: border-box;
				height:100%;
				width:20%;
				background:white;
				float:left;
				@apply --shadow-elevation-2dp;
				padding:20px;
				display:flex;
				flex-flow: column nowrap;
				align-items: flex-start;
				z-index:0;
			}

			.new-msg-btn{
				--paper-button: {
					background: var(--app-secondary-color);
					color: var(--app-text-color);
					width: 80%;
					margin: 0 auto;
					height: 48px;
				}
				--paper-button-ink-color: var(--app-secondary-color-dark);
			}
			.boxes-list{
				margin:20px auto;
				padding:0;
				min-width:80%;
			}
			.col-right{
				box-sizing: border-box;
				padding:20px;
				width:80%;
				float:right;
				margin-left:300px;
			}
			.has-unread{
				font-weight:bold;
			}
			paper-item{
				outline:0;
				cursor:pointer;
				--paper-item: {
					margin: 0;
				};
				--paper-item-selected: {
					background:rgba(0,0,0,0);
					color:var(--app-secondary-color);
				};
				--paper-item-focused: {
					background:rgba(0,0,0,0);
					color:var(--app-secondary-color);
				};
				--paper-item-focused-before: {
					background:rgba(0,0,0,0);
				}
			}


			paper-listbox:focus{
				outline:0;
			}

			.sublist{
				padding-left:20px;
				outline:0;

			}

			.sublist paper-item{
				--paper-item-min-height: 28px;
			}

			vaadin-grid.material {
				outline: 0!important;
				font-family: Roboto, sans-serif;
				background:rgba(0,0,0,0);
				border:none;
				--divider-color: rgba(0, 0, 0, var(--dark-divider-opacity));

				--vaadin-grid-cell: {
					padding: 8px;
				};

				--vaadin-grid-header-cell: {
					height: 48px;
					padding:11.2px;
					color: rgba(0, 0, 0, var(--dark-secondary-opacity));
					font-size: 12px;
					background:rgba(0,0,0,0);
					border-top:0;
				};

				--vaadin-grid-body-cell: {
					height: 48px;
					color: rgba(0, 0, 0, var(--dark-primary-opacity));
					font-size: 13px;
				};

				--vaadin-grid-body-row-hover-cell: {
					background-color: var(--paper-grey-200);
				};

				--vaadin-grid-body-row-selected-cell: {
					background-color: var(--paper-grey-100);
				};

				--vaadin-grid-focused-cell: {
					box-shadow: none;
					font-weight: bold;
				};

			}
			vaadin-grid.material .cell {
				overflow: hidden;
				text-overflow: ellipsis;
				padding-right: 56px;
			}

			vaadin-grid.material .cell.last {
				padding-right: 24px;
				text-al
			}

			vaadin-grid.material .cell.numeric {
				text-align: right;
			}

			vaadin-grid.material paper-checkbox {
				--primary-color: var(--paper-indigo-500);
				margin: 0 24px;
			}

			vaadin-grid.material vaadin-grid-sorter {
				--vaadin-grid-sorter-arrow: {
					display: none !important;
				};
			}

			vaadin-grid.material vaadin-grid-sorter .cell {
				flex: 1;
				display: flex;
				justify-content: space-between;
				align-items: center;
			}

			vaadin-grid.material vaadin-grid-sorter iron-icon {
				transform: scale(0.8);
			}

			vaadin-grid.material vaadin-grid-sorter:not([direction]) iron-icon {
				color: rgba(0, 0, 0, var(--dark-disabled-opacity));
			}

			vaadin-grid.material vaadin-grid-sorter[direction] {
				color: rgba(0, 0, 0, var(--dark-primary-opacity));
			}

			vaadin-grid.material vaadin-grid-sorter[direction=desc] iron-icon {
				transform: scale(0.8) rotate(180deg);
			}


			vaadin-grid.material ::slotted(div){
				outline:0 !important;
				background:red;
			}

			paper-checkbox{
				--paper-checkbox-unchecked-color: var(--app-text-color);
				--paper-checkbox-unchecked-ink-color: var(--app-secondary-color);
				--paper-checkbox-checkmark-color: var(--app-secondary-color);
				--paper-checkbox-checked-color: var(--app-primary-color);
			}
		</style>

		<div class="col-left">
			<paper-button class="new-msg-btn">[[localize('new_mes','New Message',language)]]</paper-button>
			<paper-listbox class="boxes-list">
				<collapse-button>
					<paper-item class="has-unread">Inbox (7)</paper-item>
					<paper-listbox class="sublist">
						<paper-item  class="has-unread">Lab Results (3)</paper-item>
						<paper-item>[[localize('per','Personal',language)]]</paper-item>
						<paper-item class="has-unread">Patients (4)</paper-item>
					</paper-listbox>
				</collapse-button>
				<paper-item>[[localize('sen_mes','Sent Messages',language)]]</paper-item>
				<paper-item>[[localize('archiv','Archived',language)]]</paper-item>
				<paper-item>[[localize('spa','Spam',language)]]</paper-item>
				<paper-item>[[localize('tra','Trash',language)]]</paper-item>
			</paper-listbox>
		</div>
		<div class="col-right">
			<vaadin-grid id="grid" class="material" page-size="10">

				<vaadin-grid-column width="66px" flex="0" >
					<template class="header">
						<paper-checkbox ></paper-checkbox>
					</template>
					<template>
						<paper-item>[[localize('spa','Spam',language)]]</paper-item>
						<paper-checkbox ></paper-checkbox>
					</template>
	</vaadin-grid-column>

	<vaadin-grid-column >
		<template class="header">[[localize('rec','Recipient',language)]]</template>
		<template>
			[[item.name.first]]
		</template>
	</vaadin-grid-column>

	<vaadin-grid-column>
		<template class="header">[[localize('sub','Subject',language)]]</template>
		<template>
			[[item.name.last]]
		</template>
	</vaadin-grid-column>

	<vaadin-grid-column style="width:100px;" flex="0">
		<template class="header">[[localize('dat','Date',language)]]</template>
		<template>
			<div>[[item.name.first]].[[item.name.last]]@example.com</div>
		</template>
	</vaadin-grid-column>

	</vaadin-grid>
	</div>
	</template>

	<script>

import moment from 'moment/src/moment';
import _ from 'lodash/lodash';
import styx from '../../../scripts/styx';
import { AccessLogDto } from "../icc-api/model/AccessLogDto";

class HtMsgMenu extends Polymer.TkLocalizerMixin(Polymer.Element) {
	static get is() {
		return 'ht-msg-menu';
	}

	static get properties() {
		return {
			api: {
				type: Object
			},
			user: {
				type: Object
			},
			selectedMainElements: {
				type: Array,
				observer: "selectedMainElementsChanged",
				value: function () {
					return [];
				}
			},
			events: {
				type: Array,
				value: function () {
					return [];
				}

			},
			selectedLocalize: {
				type: Array,
				value: function () {
					return [];
				}
			},
			selected: {
				type: Boolean,
				value: false
			},
			showFiltersPanel: {
				type: Boolean,
				value: false
			},
			msgSearchString: {
				type: String,
				value: null
			},
			showDetailsFiltersPanel: {
				type: Boolean,
				value: false
			},
			isLatestYear: {
				type: Boolean,
				value: false
			},
			selectedContactItems: {
				type: Array,
				value: function () {
					return [];
				}
			},
			itemSelected: {
				type: Boolean,
				value: false
			},
			i18n: {
				type: Object
			}
		};
	}

	static get observers() {
		return [];
	}

	constructor() {
		super();
	}

	selectedContactItemsChanged() {
		const ctcDetailPanel = this.shadowRoot.querySelector('#ctcDetailPanel');
		ctcDetailPanel && ctcDetailPanel.flushSave();

		this.set('selectedContacts', this.selectedContactItems.map(i => i.contact));
	}

	_shortId(id) {
		return id && id.substr(0, 8);
	}

	_timeFormat(date) {
		return this.api.moment(date).format(date > 99991231 ? 'DD/MM/YYYY HH:mm' : 'DD/MM/YYYY');
	}

	_dateFormat(date) {
		return this.api.moment(date).format('DD/MM/YYYY');
	}

	_contactClasses(contact) {
		return contact.closingDate ? '' : 'current-contact';
	}

	clearEvent(el) {
		const svcId = el.target.parentElement.parentElement.id.substr(5);
		const svc = this.get('events').find(s => s.id === svcId);

		const t = svc.tags.find(t => t.type === 'CD-LIFECYCLE');
		if (t) {
			t.code = 'cancelled';
			if (!this.currentContact) {
				return;
			}
			this.saveService(svc).then(c => this.filterEvents());
		}
	}

	completeEvent(el) {
		const svcId = el.target.parentElement.parentElement.id.substr(5);
		const svc = this.get('events').find(s => s.id === svcId);

		const t = svc.tags.find(t => t.type === 'CD-LIFECYCLE');
		if (t) {
			t.code = 'completed';
			if (!this.currentContact) {
				return;
			}
			this.saveService(svc).then(c => this.filterEvents());
		}
	}

	saveService(svc) {
		svc.modified = +new Date();
		if (!svc.id) {
			svc.id = this.api.crypto().randomUuid();
		}
		if (!svc.valueDate) {
			svc.valueDate = parseInt(moment().format('YYYYMMDDHHmmss'));
		}
		if (!svc.openingDate) {
			svc.openingDate = svc.valueDate;
		}
		if (!svc.created) {
			svc.created = svc.modified;
		}
		const ctc = this.api.contact().contactOfService(this.get('contacts'), svc.id) || this.currentContact;
		let sc = this.currentContact.subContacts.find(sc => sc.services.find(sId => svc.id));
		if (!sc) {
			sc = ctc.subContacts.find(sc => sc.services.find(sId => svc.id)) || {};
			this.currentContact.subContacts.push(sc = { formId: sc.formId, planOfActionId: sc.planOfActionId, healthElementId: sc.healthElementId, services: [] });
			sc.services.push({ serviceId: svc.id });
		}
		const oldSvcIdx = this.currentContact.services.findIndex(s => s.id === svc.id);
		if (oldSvcIdx > -1) {
			this.currentContact.services.splice(oldSvcIdx, 1);
		}
		this.currentContact.services.push(svc);
		return this.saveCurrentContact();
	}

	saveContact(ctc) {
		return (ctc.rev ? this.api.contact().modifyContact(ctc) : this.api.contact().createContact(ctc)).then(c => {
			ctc.rev = c.rev;
			console.log("contact saved: " + ctc.id + ":" + ctc.rev);

			setTimeout(() => this.$.savedIndicator.classList.remove("saved"), 2000);
			this.$.savedIndicator.classList.add("saved");

			if (ctc.services.find(s => s.tags.find(t => t.type === 'CD-ITEM' && ['allergy', 'risk', 'familyrisk', 'healthcareelement', 'healthissue', 'medication'].indexOf(t.code) >= 0))) {
				this.patientChanged();
			}
			return c;
		});
	}

	saveCurrentContact() {
		return this.saveContact(this.currentContact);
	}

	_saveContact(event) {
		this.saveContact(event.detail);
	}

	filterEvents() {
		this.set('events', _.sortBy(this.api.contact().filteredServices(this.contacts, s => s.tags.find(t => t.type === 'CD-LIFECYCLE' && t.code === 'planned')), it => -this.api.moment(it.valueDate)));
	}

	_lateEventCssClass(e) {
		return this.api.moment(e.valueDate).isBefore(moment()) ? 'todo-item--late' : '';
	}

	_isLatestYearContact(contactYear, contactYears) {
		if (contactYear.year === contactYears[Object.keys(contactYears)[0]].year) {
			this.isLatestYear = true;
			return "contact--big";
		} else {
			this.isLatestYear = false;
			return "contact--small";
		}
	}

	openToast() {
		Polymer.dom(this.root).querySelector('#selectionToast').show();
	}

	toggleFiltersPanel() {
		this.showFiltersPanel = !this.showFiltersPanel;
		this.root.querySelector('#filtersPanel').classList.toggle('filters-panel--collapsed');
	}

	selectedItemsSubmenu(list, selectedItems) {
		if (!selectedItems || selectedItems.length === 0) {
			return 'icons:check-box-outline-blank';
		} else if (selectedItems.length < list.length) {
			return 'icons:indeterminate-check-box';
		} else {
			return 'icons:check-box';
		}
	}

	checkedUncheckedIcon(item, selectedItems) {
		if (selectedItems && selectedItems.find(i => i && i.id && i.id.endsWith(item.id))) {
			return 'icons:check-box';
		} else {
			return 'icons:check-box-outline-blank';
		}
	}

	patientOpened(patientId, api, user) {
		if (api && user && patientId && patientId !== this.latestPatientId) {
			this.latestPatientId = patientId;
			this.api.accesslog().createAccessLog(new AccessLogDto({
				id: this.api.crypto().randomUuid(),
				patientId: patientId,
				user: user.id,
				date: +new Date(),
				accessType: 'USER_ACCESS'
			}));
		}
	}

	patientChanged(api, user, patient, forceCreate = true) {
		if (this.api && this.user && this.patient) {
			const patient = this.patient;
			Promise.all([this.api.contact().findBy(this.user.healthcarePartyId, patient), this.api.helement().findBy(this.user.healthcarePartyId, patient)]).then(([ctcs, hes]) => {
				const descrPattern = this.user.properties.find(p => p.type.identifier === 'org.taktik.icure.preferred.contactDescription') || "{Motifs de contact}";
				const sorter = x => [-x.valueDate || -x.openingDate, -x.closingDate];
				const idServicesInHes = _.compact(hes.map(he => he.idService));

				this.api.contact().filterServices(ctcs, s => s.tags.find(c => c.type === 'CD-ITEM' && ['healtcarehelement', 'healthissue', 'familyrisk', 'risk', 'allergy'].includes(c.code)) && !idServicesInHes.includes(s.id)).then(hesAsServices => {
					const combinedHes = _.sortBy(_.concat(hesAsServices.map(svc => ({
						created: svc.created,
						modified: svc.modified,
						endOfLife: svc.endOfLife,
						author: svc.author,
						responsible: svc.responsible,
						codes: svc.codes,
						tags: svc.tags,
						valueDate: svc.valueDate,
						openingDate: svc.openingDate,
						closingDate: svc.closingDate,
						descr: this.shortServiceDescription(svc, this.language),
						idService: svc.id,
						status: svc.status,
						svc: svc,
						plansOfAction: [] })), hes.filter(it => it.descr && !it.descr.startsWith('Etat g') && !it.descr.startsWith('Algemeen t') && it.descr !== 'INBOX')), sorter);

					combinedHes.forEach(e => {
						e.selectedItems = [];
					});

					this.api.code().icdChapters(_.compact(combinedHes.map(he => he.codes.find(c => c.type === 'ICD' || c.type === 'ICD10'))).map(x => x.code)).then(codes => {
						codes.forEach(cc => {
							cc.healthElements = _.sortBy(combinedHes.filter(he => {
								let heIcd = he.codes.find(c => c.type === 'ICD' || c.type === 'ICD10');
								return heIcd && cc.subCodes.includes(heIcd.code);
							}), sorter);
							cc.healthElements.forEach(he => he.colour = cc.descr.colour);
						});
						this.set('healthTopics', _.sortBy(codes.filter(ht => ht.healthElements.length > 1), it => this.api.contact().localize(it, this.language)));

						this.set('activeHealthElements', _.sortBy(combinedHes.filter(it => !it.closingDate && (it.status & 1) === 0 && it.tags.find(c => c.type === 'CD-ITEM' && (c.code === 'healthissue' || c.code === 'healthcareelement'))), 'descr'));
						this.set('inactiveHealthElements', _.sortBy(combinedHes.filter(it => (it.closingDate || (it.status & 1) === 1) && (it.status & 2) === 0 && it.tags.find(c => c.type === 'CD-ITEM' && (c.code === 'healthissue' || c.code === 'healthcareelement'))), 'descr'));
						this.set('archivedHealthElements', _.sortBy(combinedHes.filter(it => (it.status & 2) === 2), 'descr'));
						this.set('allergies', _.sortBy(combinedHes.filter(it => (it.status & 2) === 0 && it.tags.find(c => c.type === 'CD-ITEM' && c.code === 'allergy')), 'descr'));
						this.set('risks', _.sortBy(combinedHes.filter(it => (it.status & 2) === 0 && it.tags.find(c => c.type === 'CD-ITEM' && c.code === 'risk')), 'descr'));
						this.set('familyrisks', _.sortBy(combinedHes.filter(it => (it.status & 2) === 0 && it.tags.find(c => c.type === 'CD-ITEM' && c.code === 'familyrisk')), 'descr'));
					});

					const unclosedContact = ctcs.find(c => !c.closingDate);
					const allContacts = unclosedContact ? ctcs.concat([unclosedContact]) : ctcs;
					const templateKeys = descrPattern.match(/\{.+?\}/g).map(s => s.substring(1, s.length - 1)).reduce((acc, s) => {
						acc[s] = true;return acc;
					}, {});
					allContacts.forEach(ctc => {
						ctc.healthElements = Object.values(ctc.subContacts.map(sc => sc.planOfActionId && combinedHes.find(he => he.plansOfAction.find(poa => poa.id === sc.planOfActionId)) || sc.healthElementId && combinedHes.find(he => he.id === sc.healthElementId)).reduce((acc, x) => {
							x && x.id && (acc[x.id] = x);return acc;
						}, {}));
						ctc.userDescr = this.api.template(descrPattern, ctc.services.filter(s => templateKeys[s.label] && !s.endOfLife).reduce((acc, v) => {
							acc[v.label] = !acc[v.label] ? this.shortServiceDescription(v, this.language) : acc[v.label] + "," + this.shortServiceDescription(v, this.language);return acc;
						}, {}));
						if (!ctc.userDescr || ctc.userDescr.length < 3) {
							ctc.userDescr = ctc.descr;
						}
					});(unclosedContact && Promise.resolve(unclosedContact) || this.api.contact().newInstance(this.user, patient, { descr: 'Contact du jour', userDescr: 'Contact du jour' })).then(newCtc => {
						const thisYear = moment().year();
						this.set('contacts', ctcs);
						this.set('currentContact', newCtc);
						this.set('contactYears', _.sortBy(_.values(_.reduce(ctcs, (acc, ctc) => {
							if (ctc.subContacts && ctc.subContacts.length || ctc.services.find(s => _.values(s.content).find(this.contentHasData.bind(this)))) {
								let year = parseInt((ctc.openingDate || 2000).toString().substr(0, 4));
								const contacts = (acc[year] || (acc[year] = { year: year, contacts: [] })).contacts;
								if (!contacts.includes(ctc)) {
									contacts.push(ctc);
								}
							}
							return acc;
						}, _.fromPairs([[thisYear, { year: thisYear, contacts: [newCtc] }]]))).map(x => {
							x.contacts = _.sortBy(x.contacts, sorter);return x;
						}), x => -x.year));
						this.filterEvents();
					});
				});

				this.api.contact().filterServices(ctcs, s => s.tags.find(c => c.type === 'CD-ITEM' && c.code === 'medication')).then(medications => this.set('medications', _.sortBy(medications, sorter)));

				this._updateFilterPanels();
			});

			//eHealth stuff
			if (patient.ssin && this.api.tokenId) {
				this.api.hcparty().getHealthcareParty(this.user.healthcarePartyId).then(hcp => this.api.fhc().Geninscontroller().getGeneralInsurabilityUsingGET(patient.ssin, this.api.tokenId, this.api.keystoreId, this.api.credentials.ehpassword, hcp.nihii, hcp.ssin, hcp.lastName, "doctor", null, null).then(gi => {
					const genInsOk = !gi.faultCode && gi.insurabilities && gi.insurabilities.length && gi.insurabilities[0].ct1 && !(gi.generalSituation && gi.generalSituation.length);
					const medicalHouse = gi.medicalHouseInfo && gi.medicalHouseInfo.medical && this.api.before(gi.medicalHouseInfo.periodStart, +new Date()) && (!gi.medicalHouseInfo.periodEnd || this.api.after(gi.medicalHouseInfo.periodEnd + 24 * 3600 * 1000, +new Date()));

					this.$.insuranceStatus.classList.remove('medicalHouse');
					this.$.insuranceStatus.classList.remove('noInsurance');
					this.$.insuranceStatus.classList.remove('insuranceOk');

					this.$.insuranceStatus.classList.add(genInsOk ? medicalHouse ? 'medicalHouse' : 'insuranceOk' : 'noInsurance');
					Polymer.updateStyles(this.$.insuranceStatus);

					if (genInsOk) {
						//set gen ins info on patient
						const pi = patient.insurabilities && _.assign({}, patient.insurabilities[0] || {});
						const ins = gi.insurabilities[0];
						this.api.insurance().listInsurancesByCode(ins.mutuality).then(out => {
							if (out && out.length) {
								pi.insuranceId = out[0].id;
							}
							if (ins.ct1 && (!pi.parameters || pi.parameters.tc1 !== ins.ct1)) {
								pi.parameters = _.assign(pi.parameters || {}, { tc1: ins.ct1, preferentialstatus: parseInt(ins.ct1) % 2 === 1 ? 'true' : 'false' });
							}
							ins.ct2 && pi.parameters.tc2 !== ins.ct2 && (pi.parameters = _.assign(pi.parameters || {}, { tc2: ins.ct2 }));
							ins.paymentApproval ? pi.parameters = _.assign(pi.parameters || {}, { paymentapproval: 'true' }) : delete pi.parameters.paymentapproval;
							if (patient === this.patient) {
								this.set('patient.insurabilities.0', pi);
							}
						});
					}
				}));
			}
		}
	}

	unselectAdminFile() {
		this.$.adminFileMenu.select(null);
	}

	newContact(e) {
		this.patientChanged();
	}

	closeContact(e) {
		e.stopPropagation();
		e.preventDefault();

		const ctcId = e.target.id.substr(6);
		const year = this.contactYears.find(y => y.contacts.find(c => c.id === ctcId));
		const contact = year.contacts.find(c => c.id === ctcId);

		if (contact) {
			if (!contact.rev && (!contact.services || contact.services.length === 0)) {
				const idx = this.contactYears[0].contacts.indexOf(this.currentContact);
				if (idx >= 0) {
					this.splice('contactYears.0.contacts', idx, 1);
				}
				this.set('currentContact', null);
			} else {
				this.api.contact().getContact(contact.id).then(c => {
					c.closingDate = parseInt(moment().format('YYYYMMDDHHmmss'));
					(c.rev ? this.api.contact().modifyContact(c) : this.api.contact().createContact(c)).then(() => this.patientChanged());
					//this.notifyPath('currentContact.closingDate')
				});
			}
		}
	}

	selectedMainElementItemsChanged(event) {
		const domRepeat = event.target.querySelector("dom-repeat");
		const selectedModels = event.target.selectedItems.map(el => domRepeat.modelForElement(el).he);

		if (!domRepeat || !selectedModels) {
			return;
		}
		const allModels = domRepeat.items || [];

		this.set('selectedMainElements', this.selectedMainElements.filter(he => !allModels.includes(he)).concat(selectedModels));
	}

	isMainElementSelected(item, selectedItems) {
		return selectedItems && selectedItems.includes(item);
	}

	selectedMainElementsSpliced(changeRecord) {
		if (changeRecord) {
			this.updateContactYears();
		}
	}

	_archive(event) {
		const model = event.detail;
		if (model.he.id) {
			this.api.helement().getHealthElement(model.he.id).then(he => {
				if (!he.closingDate && he.closingDate !== 0) {
					he.closingDate = parseInt(moment().format('YYYYMMDDHHmmss'));
				}
				if ((he.status & 1) === 0) {
					he.status = he.status | 1;
				}
				if ((he.status & 2) === 0) {
					he.status = he.status | 2;
				}
				this.api.helement().modifyHealthElement(he).then(() => {
					this.patientChanged();
				});
			});
		} else if (model.he.idService) {
			if (!this.currentContact) {
				return;
			}
			const svc = model.he.svc;

			if (!svc.closingDate && svc.closingDate !== 0) {
				svc.closingDate = parseInt(moment().format('YYYYMMDDHHmmss'));
			}
			if ((svc.status & 2) === 0) {
				svc.status = svc.status | 2;
			}
			this.saveService(svc).then(c => this.patientChanged());
		}
	}

	_activate(event) {
		const model = event.detail;
		if (model.he.id) {
			this.api.helement().getHealthElement(model.he.id).then(he => {
				if (he.closingDate || he.closingDate === 0) {
					he.closingDate = null;
				}
				if ((he.status & 1) === 1) {
					he.status = he.status - 1;
				} //activate
				if ((he.status & 2) === 2) {
					he.status = he.status - 2;
				} //unarchive
				this.api.helement().modifyHealthElement(he).then(he => {
					this.patientChanged();
				});
			});
		} else if (model.he.idService) {
			if (!this.currentContact) {
				return;
			}
			const svc = model.he.svc;

			if (svc.closingDate || svc.closingDate === 0) {
				svc.closingDate = null;
			}
			if ((svc.status & 1) === 1) {
				svc.status = svc.status - 1;
			} //activate
			if ((svc.status & 2) === 2) {
				svc.status = svc.status - 2;
			} //unarchive
			this.saveService(svc).then(c => this.patientChanged());
		}
	}

	_inactivate(event) {
		const model = event.detail;
		if (model.he.id) {
			this.api.helement().getHealthElement(model.he.id).then(he => {
				if (!he.closingDate && he.closingDate !== 0) {
					he.closingDate = parseInt(moment().format('YYYYMMDDHHmmss'));
				}
				if ((he.status & 2) === 2) {
					he.status = he.status - 2;
				} //unarchive
				this.api.helement().modifyHealthElement(he).then(he => {
					this.patientChanged();
				});
			});
		} else if (model.he.idService) {
			if (!this.currentContact) {
				return;
			}
			const svc = model.he.svc;

			if (!svc.closingDate && svc.closingDate !== 0) {
				svc.closingDate = parseInt(moment().format('YYYYMMDDHHmmss'));
			}
			if ((svc.status & 2) === 2) {
				svc.status = svc.status - 2;
			} //unarchive

			this.saveService(svc).then(c => this.patientChanged());
		}
	}

	_selectToday() {
		this.$.adminFileMenu.select(1);

		this.set('timeSpanStart', parseInt(moment().startOf('day').format('YYYYMMDD')));
		this.set('timeSpanEnd', null);

		this.updateContactYears();
	}

	_select6Months() {
		this.set('timeSpanStart', parseInt(moment().subtract(6, 'month').format('YYYYMMDD')));
		this.set('timeSpanEnd', null);

		this.updateContactYears();
	}

	_selectAll() {
		this.set('timeSpanStart', null);
		this.set('timeSpanEnd', null);

		this.updateContactYears();
	}

	_selectCurrentContact() {
		this.shadowRoot.querySelector('#_contacts_listbox').set('selectedValues', [0]);
	}

	updateContactYears() {
		this.notifyPath('contactYears');
	}

	getHeId(he) {
		return he.id ? `_he_${he.id}` : `_svc_${he.idService}`;
	}

	contactFilter() {
		return function (ctc) {
			const regExp = this.contactSearchString && new RegExp(this.contactSearchString, "i");

			const heIds = this.selectedMainElements.map(he => he.id);
			const poaIds = _.flatMap(this.selectedMainElements, he => he.selectedPlansOfAction ? he.selectedPlansOfAction.map(p => p.id) : []);
			const svcIds = this.selectedMainElements.filter(he => !he.id).map(he => he.idService);

			return this.api.after(ctc.openingDate, this.timeSpanStart) && this.api.before(ctc.openingDate, this.timeSpanEnd) && (!regExp || ctc.subContacts.filter(sc => sc.descr && sc.descr.match(regExp) && sc.services.length).length || ctc.services.filter(s => this.shortServiceDescription(s, this.language).match(regExp)).length) && (!heIds.length && !poaIds.length && !svcIds.length || ctc.subContacts.filter(sc => (sc.healthElementId && heIds.includes(sc.healthElementId) || sc.planOfActionId && poaIds.includes(sc.planOfActionId)) && sc.services.length).length || ctc.services.filter(s => svcIds.includes(s.id)).length) || !ctc.closingDate;
		}.bind(this);
	}

	compareContacts(a, b) {
		return b.created - a.created;
	}

	close() {
		this.set('patient', null);
	}

	selectedAdminFileChanged(el) {
		if (el && this.selectedMainElements && this.selectedMainElements.length) {
			this.set("selectedMainElements", []);
		}
		this._updateFilterPanels();
	}

	_editHealthElement(event) {
		const model = event.detail;(model.he.codes && model.he.codes.length && this.api.code().getCodes(model.he.codes.map(c => this.api.code().normalize(c).id).join(',')) || Promise.resolve([])).then(codes => {
			this.editedHealthElementModel = model;
			this.$['edit-healthelement-dialog'].set('entity', _.assign(_.assign({ plansOfAction: [] }, model.he), { codes: codes }));
			this.$['edit-healthelement-dialog'].open();
		});
	}

	toggleMenu(e) {
		e.stopPropagation();
		e.preventDefault();
		styx.parent(e.target, el => el.tagName.toLowerCase() === 'collapse-button').toggle();
		styx.parent(e.target, el => el.tagName.toLowerCase() === 'paper-item').classList.toggle('opened');

		this._updateFilterPanels();
	}

	getPaperItemParentForEvent(e) {
		let tgt = e.target;
		while (tgt && tgt.tagName && tgt.tagName.toLowerCase() !== 'paper-item') {
			tgt = tgt.parentElement;
		}
		return tgt && tgt.tagName ? tgt : null;
	}

	getPaperListboxParent(tgt) {
		while (tgt && tgt.tagName && tgt.tagName.toLowerCase() !== 'paper-listbox') {
			tgt = tgt.parentElement;
		}
		return tgt && tgt.tagName ? tgt : null;
	}

	handleSelectionChange(e) {
		const selections = e.detail.selections;
		const selChanges = {};

		selections.forEach(s => {
			(s.items || this.selectedMainElements.map(he => this.getHeId(he))).forEach(id => {
				const item = this.root.querySelector('#' + id);
				if (item) {
					const listBox = this.getPaperListboxParent(item);
					if (listBox) {
						const selChangesEntry = selChanges[listBox.id] || (selChanges[listBox.id] = { el: listBox, selectedValues: listBox.selectedValues });
						if (s.action === 'select') {
							selChangesEntry.selectedValues = _.uniq(selChanges[listBox.id].selectedValues.concat([listBox.items.indexOf(item)]));
						} else if (s.action === 'unselect') {
							const delValue = listBox.items.indexOf(item);
							selChangesEntry.selectedValues = selChanges[listBox.id].selectedValues.filter(it => it !== delValue);
						}
					}
				}
			});
		});
		Object.values(selChanges).forEach(c => c.el.set('selectedValues', c.selectedValues));
	}

	isNotEmpty(a) {
		return a && a.length > 0;
	}

	isEmpty(a) {
		return !a || a.length === 0;
	}

	isAdminSelected(el) {
		return el && el.id === '_admin_info';
	}

	highlightedServiceLabels(user) {
		try {
			return user.properties.filter(p => p.type.identifier === 'org.taktik.icure.highlightedServiceLabels').map(p => JSON.parse(p.typedValue.stringValue))[0] || ['Examen clinique', 'Diagnostics', 'Prescription'];
		} catch (e) {}
		return ['Examen clinique', 'Diagnostics', 'Prescription'];
	}

	hcp(ctc) {
		const usr = this.api.users && this.api.users[ctc.author];
		const hcp = usr ? this.api.hcParties[usr.healthcarePartyId] : null;
		return hcp && hcp.lastName + " " + (hcp.firstName && hcp.firstName.length && hcp.firstName.substr(0, 1) + ".") || usr && usr.login || "N/A";
	}

	picture(pat) {
		if (!pat) {
			return require('../../../images/Male-128.jpg');
		}
		return pat.picture ? 'data:image/jpeg;base64,' + pat.picture : pat.gender === 'F' || pat.gender === 'f' ? require('../../../images/Female-128.jpg') : require('../../../images/Male-128.jpg');
	}

	serviceDescriptions(ctc, label) {
		return this.api && this.api.contact().services(ctc, label).filter(s => !s.endOfLife).map(s => this.shortServiceDescription(s, this.language)).filter(desc => desc) || [];
	}

	shortServiceDescription(svc, lng) {
		let rawDesc = svc && this.api && this.api.contact().shortServiceDescription(svc, lng);
		return rawDesc && '' + rawDesc || '';
	}

	contentHasData(c) {
		return this.api && this.api.contact().contentHasData(c) || false;
	}

	_addHealthElement(e) {
		this.$['add-healthelement-dialog'].open();
		this.$['add-healthelement-dialog'].set('entity', { plansOfAction: [], tags: (e.target.dataset.tags ? e.target.dataset.tags.split(',') : []).map(c => ({ id: c, type: c.split('|')[0], code: c.split('|')[1], version: c.split('|')[2] })) });
	}

	_addInactiveHealthElement(e) {
		this.$['add-healthelement-dialog'].open();
		this.$['add-healthelement-dialog'].set('entity', { plansOfAction: [], closingDate: parseInt(moment().format('YYYYMMDDHHmmss')), tags: (e.target.dataset.tags ? e.target.dataset.tags.split(',') : []).map(c => ({ id: c, type: c.split('|')[0], code: c.split('|')[1], version: c.split('|')[2] })) });
	}

	_addService(e) {
		this.set('editedSvcLabel', e.target.dataset.label);
		this.$['add-service-dialog'].open();
		this.$['add-service-dialog'].set('entity', { 'label': e.target.dataset.label, 'tags': (e.target.dataset.tags ? e.target.dataset.tags.split(',') : []).map(c => ({ id: c, type: c.split('|')[0], code: c.split('|')[1], version: c.split('|')[2] })) });
	}

	_healthElementsSelectorColumns() {
		return [{ key: 'descr', title: 'Description' }, { key: 'plansOfActionDescr', title: 'Plans of action' }];
	}

	_healthElementsSelectorDataProvider() {
		return {
			filter: function (filterValue, limit, offset, sortKey, descending) {
				const regExp = filterValue && new RegExp(filterValue, "i");

				return Promise.all([this.api.code().findPaginatedCodesByLabel('be', 'BE-THESAURUS', 'fr', filterValue, null, 1000), this.api.entitytemplate().findEntityTemplates(this.user.id, 'org.taktik.icure.entities.HealthElementTemplate', null, true)]).then(results => {
					const codes = results[0];
					const entityTemplates = results[1];
					const filtered = _.flatten(entityTemplates.map(et => et.entity)).filter(he => [he].concat(he.plansOfAction || []).find(it => it.descr && it.descr.match(regExp) || it.name && it.name.match(regExp))).map(it => ({ descr: it.descr || it.name, healthElement: it, plansOfAction: it.plansOfAction || [], plansOfActionDescr: (it.plansOfAction && it.plansOfAction.map(poa => poa.descr || poa.name) || []).join(',') })).concat(codes.rows.map(code => ({ descr: this.api.localize(code.label), codes: [code.id].concat(code.links), plansOfAction: [], plansOfActionDescr: 'N/A' })));
					return { totalSize: filtered.length, rows: (descending ? _.reverse(_.sortBy(filtered, sortKey)) : _.sortBy(filtered, sortKey)).slice(offset, limit) };
				});
			}.bind(this)
		};
	}

	_normalizedHealthElement(healthElement) {
		return {
			descr: healthElement.descr,
			openingDate: healthElement.openingDate || +new Date(),
			closingDate: healthElement.closingDate,
			status: healthElement.status || 0,
			plansOfAction: (healthElement.plansOfAction || []).map(poa => _.extend(poa, { id: this.api.crypto().randomUuid(), openingDate: parseInt(moment().format('YYYYMMDDHHmmss')) })),
			tags: (healthElement.tags || []).map(c => this.api.code().normalize(c)),
			codes: (healthElement.codes || []).map(c => this.api.code().normalize(c)),
			idService: healthElement.idService
		};
	}

	_addedHealthElementSelected(event, healthElement) {
		this.api.helement().newInstance(this.user, this.patient, this._normalizedHealthElement(healthElement)).then(he => this.api.helement().createHealthElement(he)).then(he => this.patientChanged());
	}

	_editedHealthElementSelected(event, healthElement) {
		if (this.editedHealthElementModel.he.id) {
			this.api.helement().getHealthElement(this.editedHealthElementModel.he.id).then(he => {
				delete healthElement.plansOfActionDescr;
				_.assign(he, this._normalizedHealthElement(healthElement));
				return he;
			}).then(he => this.api.helement().modifyHealthElement(he)).then(he => this.patientChanged());
		} else if (this.editedHealthElementModel.he.idService) {
			const svc = this.editedHealthElementModel.he.svc;
			return this.api.helement().serviceToHealthElement(this.user, this.patient, svc, this.language).then(he => {
				if (this.currentContact) {
					this.api.contact().promoteServiceInContact(this.currentContact, this.user, this.contacts, svc, undefined, null, he.id, null);
					this.saveCurrentContact().then(c => this.patientChanged());
				}

				this.editedHealthElementModel.he = he;
				return this._editedHealthElementSelected(event, healthElement);
			});
		}
	}

	_servicesSelectorColumns() {
		return [{ key: svc => svc && svc.content && this.shortServiceDescription(svc, this.language) || '', sortKey: 'content.' + this.language + '.stringValue', title: 'Description' }, { key: svc => svc && svc.codes && svc.codes.map(c => (c.type || c.id && c.id.split('|')[0]) + ':' + (c.code || c.id && c.id.split('|')[1])).join(',') || '', sortKey: 'codes.0.code', title: 'Codes' }];
	}

	_servicesSelectorDataProvider(label) {
		return {
			filter: function (filterValue, limit, offset, sortKey, descending) {
				const regExp = filterValue && new RegExp(filterValue, "i");

				return this.api.code().findPaginatedCodesByLabel('be', 'BE-THESAURUS', 'fr', filterValue, null, 1000).then(results => {
					const filtered = results.rows.map(code => ({ label: label, content: _.mapValues(code.label, v => ({ stringValue: v })), codes: code.links && code.links.map(c => ({ id: c, type: c.split('|')[0], code: c.split('|')[1], version: c.split('|')[2] })) || [] }));
					return { totalSize: filtered.length, rows: (descending ? _.reverse(_.sortBy(filtered, sortKey)) : _.sortBy(filtered, sortKey)).slice(offset, limit) };
				});
			}.bind(this)
		};
	}

	_addedOrEditedServiceSelected(event, svc) {
		if (!this.currentContact) {
			return;
		}
		this.saveService(svc).then(c => this.patientChanged());
	}

	_svcEntityContentChanged(e, value) {
		const svc = styx.parent(e.target, el => el.tagName.toLowerCase() === 'entity-selector').entity;
		const content = svc.content || (svc.content = {});(content[this.language] || (content[this.language] = {})).stringValue = value;
	}

	_updateFilterPanels() {
		setTimeout(() => {
			const cfp = Polymer.dom(this.root).querySelector("#contactFilterPanel");
			cfp && cfp.refreshIcons();
			const hpd = Polymer.dom(this.root).querySelector("ht-pat-detail-ctc-detail-panel");
			hpd && hpd.refreshIcons();
		}, 10);
	}

	_expandColumn(e) {
		this.root.querySelector('.display-left-menu').classList.toggle('open');
		this.root.querySelector('.container').classList.toggle('expanded');
		this._updateFilterPanels();
	}

	_concat(a, b) {
		return (a || []).concat(b || []);
	}

}

customElements.define(HtMsgMenu.is, HtMsgMenu);
</script>
</dom-module>
