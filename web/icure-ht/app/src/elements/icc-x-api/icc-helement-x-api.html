	<link rel="import" href="../../../bower_components/polymer/polymer.html">

	<dom-module id="icc-helement-x-api">
		<template>
			<style>
			</style>
		</template>
	</dom-module>

	<script>
		import moment from '../../../bower_components/moment/src/moment'
		(function () {
			Polymer({
				is: 'icc-helement-x-api',
				properties: {
					api: {
						type: Object
					},
					crypto: {
						type: Object
					}
				},
				behaviors: [],

				init: function () {
					this.baseApi = this.api.helement()
					Object.getOwnPropertyNames(this.baseApi.$).forEach((p)=> {
						if (this.baseApi[p] && typeof this.baseApi[p] === 'function') {
							this[p] = this.baseApi[p].bind(this.baseApi)
						}
					})
				},

				'new': function(user, patient, h) {
					const helement = _.extend({
						id: this.crypto.randomUuid(),
						_type: 'org.taktik.icure.entities.HealthElement',
						created: (new Date).getTime(),
						modified: (new Date).getTime(),
						responsible: user.healthcarePartyId,
						author: user.id,
						codes: [],
						tags: [],
						healthElementId: this.crypto.randomUuid(),
						openingDate: parseInt(moment().format('YYYYMMDDHHmmss'))
					}, h || {})

					return this.crypto.extractDelegationsSFKs(patient, user.healthcarePartyId)
						.then(secretForeignKeys => this.crypto.initObjectDelegations(helement, patient, user.healthcarePartyId, secretForeignKeys[0]))
						.then(initData => {
							_.extend(helement, {delegations: initData.delegations, cryptedForeignKeys: initData.cryptedForeignKeys, secretForeignKeys: initData.secretForeignKeys})

							let promise = Promise.resolve(helement);
							(user.autoDelegations ? (user.autoDelegations.all || []).concat(user.autoDelegations.medicalInformation || []) : []).forEach(delegateId =>
								promise = promise
									.then(contact => this.crypto.appendObjectDelegations(contact, patient, user.healthcarePartyId, delegateId, initData.secretId))
									.then(extraData => _.extend(helement, {delegations: extraData.delegations, cryptedForeignKeys: extraData.cryptedForeignKeys}))
							)
							return promise
						})
				},

				/**
				 * 1. Check whether there is a delegation with 'hcpartyId' or not.
				 * 2. 'fetchHcParty[hcpartyId][1]': is encrypted AES exchange key by RSA public key of him.
				 * 3. Obtain the AES exchange key, by decrypting the previous step value with hcparty private key
				 *      3.1.  KeyPair should be fetch from cache (in jwk)
				 *      3.2.  if it doesn't exist in the cache, it has to be loaded from Browser Local store, and then import it to WebCrypto
				 * 4. Obtain the array of delegations which are delegated to his ID (hcpartyId) in this patient
				 * 5. Decrypt and collect all keys (secretForeignKeys) within delegations of previous step (with obtained AES key of step 4)
				 * 6. Do the REST call to get all helements with (allSecretForeignKeysDelimitedByComa, hcpartyId)
				 *
				 * After these painful steps, you have the helements of the patient.
				 *
				 * @param hcparty
				 * @param patient (Promise)
				 */
				findBy: function (hcpartyId, patient) {
					if (!patient.delegations || !patient.delegations[hcpartyId] || !(patient.delegations[hcpartyId].length > 0)) {
						throw 'There is not delegation for this healthcare party(' + hcpartyId + ') in patient(' + patient.id + ')';
					}

					return this.crypto.decryptAndImportAesHcPartyKeysInDelegations(hcpartyId, patient.delegations).then(function (decryptedAndImportedAesHcPartyKeys) {
						var collatedAesKeys = {};
						decryptedAndImportedAesHcPartyKeys.forEach(k => collatedAesKeys[k.delegatorId] = k.key);

						return this.crypto.decryptDelegationsSFKs(patient.delegations[hcpartyId], collatedAesKeys, patient.id)
								.then(secretForeignKeys => this.api.helement().findByHCPartyPatientSecretFKeys(hcpartyId, secretForeignKeys.join(',')))
								.then(helements => this.decrypt(hcpartyId, helements))
								.then(function (decryptedHelements) {
									const byIds = {}
									decryptedHelements.forEach(he => {
										if (he.healthElementId) {
											const phe = byIds[he.healthElementId]
											if (!phe || !phe.modified || (he.modified && phe.modified < he.modified)) {
												byIds[he.healthElementId] = he
											}
										}
									})
									return _.values(byIds).filter(s=>!s.endOfLife)
								})
					}.bind(this))
				},

				decrypt: function (hcpartyId, hes) {
					return Promise.all(hes.map(he => this.crypto.decryptAndImportAesHcPartyKeysInDelegations(hcpartyId, he.delegations).then(function (decryptedAndImportedAesHcPartyKeys) {
						var collatedAesKeys = {};
						decryptedAndImportedAesHcPartyKeys.forEach(k => collatedAesKeys[k.delegatorId] = k.key);
						return this.crypto.decryptDelegationsSFKs(he.delegations[hcpartyId], collatedAesKeys, he.id).then(sfks=> {
							if (he.encryptedDescr) {
								return this.crypto.AES.importKey('raw', this.crypto.utils.hex2ua(sfks[0].replace(/-/g, '')))
										.then(key => new Promise((resolve, reject) => this.crypto.AES.decrypt(key,
												this.crypto.utils.text2ua(atob(he.encryptedDescr))).then(resolve)
												.catch(err=> {
													console.log("Error, could not decrypt: " + err);
													resolve(null)
												}))
										).then(decrypted => {
											if (decrypted) {
												he.descr = decrypted
											}
											return he
										});
							} else {
								return Promise.resolve(he)
							}
						})
					}.bind(this))))
				}
			})
		})();
	</script>

@end
